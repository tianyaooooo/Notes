# 模块一：线性结构【把所有的结点用一根直线串起来】 

## 1. 连续存储【数组】

### 定义
数组是相同数据类型的元素的集合  

数组中的各元素的存储是有先后顺序的，它们在内存中按照这个先后顺序连续存放在一起


### 算法
查找、排序、倒置、追加结点、插入结点、删除结点等  

代码实现详见 ArrayList.cpp

### 数组的优缺点（相比于链表）
优点：存取速度快  

缺点：事先必须知道数组的长度、空间通常是有限制的、需要大块连续的内存、插入删除元素很慢

## 2. 离散存储【链表】
### 定义
n 个结点离散分配  

彼此通过指针相连  

每个结点只有一个前驱结点、每个结点只有一个后续结点（首结点没有前驱结点，尾结点没有后续结点）  

### 专业术语

首结点：第一个有效（存放有效数据）的结点  

尾结点：最后一个有效节点  

头结点：第一个有效结点之前的那个结点，数据类型与首结点类型一样，但并不存放有效数据，目的是为了方便对链表的操作  

头指针：指向头结点的指针变量  

尾指针：指向尾结点的指针变量

### 找到一个链表需要几个参数？
只需要1个参数——头指针，因为通过头指针我们可以推出链表的其他所有信息

### 每一个链表结点的数据类型表示
```C++
typedef struct Node
{
	int data; //数据域 
	struct Node * pNext; // 指针域，指向一个与它本身类型一模一样的另一个结点 
} NODE, * PNODE; // NODE 等价于 struct Node, PNODE 等价于 struct Node * 
```

### 分类
单链表  
双链表：每一个结点有两个指针域  

循环链表：能通过任何一个结点找到其他所有的结点  
非循环链表

### 算法
遍历、查找、清空、销毁、求长度、排序、删除结点、插入结点等  

代码实现详见 LinkedList.cpp

### 链表的优缺点（相比于数组）
优点：空间没有限制、插入删除元素很快 

缺点：存取速度很慢


## 3. 线性结构的两种常见应用之一 栈
### 定义  
一种可以实现“先进后出”的存储结构/方式

### 分类  
静态栈【数组方式实现-顺序栈】

动态栈【链表方式实现-链栈】

### 算法
出栈、压栈等

静态栈的代码实现详见 Stack_with_Arraylist.cpp  

动态栈的代码实现详见 Stack_with_Linkedlist.cpp

### 应用
函数调用、中断、表达式求值（比如计算器的实现）、内存分配、缓冲处理、迷宫等  

函数调用详见递归专题  

计算器（自然数的四则运算）的代码实现详见 Calculator.cpp


## 3. 线性结构的两种常见应用之二 队列
### 定义  
一种可以实现“先进先出”的存储结构/方式

### 分类
动态队列【链表方式实现】  

静态队列【数组方式实现】——静态队列通常都必须是循环队列  

关于循环队列：
* 静态队列为什么必须是循环队列？  
若不使用循环队列，会浪费存储空间（数组只能使用一次），造成“假溢出”现象。  
如图所示，下标为 0 和 1 的位置还是空闲，但因数组末尾元素已占用，再向后加，会产生数组越界的错误，位置 0 和 1 浪费了。  
![](https://note.youdao.com/yws/api/personal/file/WEBbd73f80788e19bdae1775cfd8ebab395?method=download&shareKey=719c118ea1d6c585f6823cb33c2278f7)


* 循环队列需要几个参数来确定？  
需要2个参数来确定，分别是 front 和 rear。  


* 循环队列各个参数的含义？  
2个参数在不同场合有不同的含义  
队列初始化时：front 和 rear 的值都是零。   
队列非空时：front 代表的是队列的第一个元素，rear 代表的是队列的最后一个有效元素的下一个元素。  
队列空时：front 和 rear 的值相等，但不一定为零。  

* 循环队列入队伪算法  
将值存入 r 所代表的位置 --> rear = (rear + 1) % 数组的长度 // r++ 错误

* 循环队列出队伪算法  
front = (front + 1) % 数组的长度  

* 如何判断循环队列为空？  
如果 front 与 rear 的值相等，则队列就一定为空。  

* 如何判断循环队列已满？  
注意：front 的值可能比 rear 大，也可能比 rear 小，也可能相等。  
方式一：设置一个标志变量 flag，当 front = rear，且 flag = 0 时队列为空，当 front = rear，且 flag = 1 时队列为满。  
方式二：少用一个元素，即规定当队列元素个数为 n - 1 时队列满（设数组长度为 n）。判定条件：(rear + 1) % 数组的长度 = front

### 算法
入队、出队等

静态队列的代码实现详见 Queue_with_Arraylist.cpp  

动态队列的代码实现详见 Queue_with_Linkedlist.cpp

### 应用
所有和时间有关的操作都有队列的影子
